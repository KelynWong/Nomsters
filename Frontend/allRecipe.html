<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>All Recipe</title>

  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.1/dist/css/bootstrap.min.css" rel="stylesheet"
    integrity="sha384-4bw+/aepP/YC94hEpVNVgiZdgIC5+VKNBQNGCHeKRQN+PtmoHDEXuppvnDJzQIu9" crossorigin="anonymous">
    <!-- Font awesome for icon -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.0/css/all.min.css">

  <link rel="stylesheet" href="css/master.css">
  <link rel="stylesheet" href="css/recipe.css">

  <script src="https://unpkg.com/axios/dist/axios.min.js"></script>
  <script src="https://unpkg.com/vue@next"></script>
</head>
<body>
    <script>
        const token = sessionStorage.getItem('token');
        const userId = sessionStorage.getItem('userId');
          
        if (!token || !userId) {
            // If 'token' or 'userId' doesn't exist, redirect to 'index.html'
            window.location.href = './index.html';
        }
    </script>
    
    <div id="app">
        <app-nav :allrecipes="allrecipes" @search="searchRecipes"></app-nav>
        <h2>{{ titlequery }}</h2>
        <div class="recipeContent">
            <div class="dropdown d-flex justify-content-end">
                <button class="btn dropdown-toggle border border-secondary" type="button" data-bs-toggle="dropdown" aria-expanded="false">
                    {{ selectedOption}}
                </button>
                <ul id="sort" class="dropdown-menu">
                    <li v-for="(option, index) in options" :key="index" >
                        <div class="dropdown-item" @click="selectOption(option); searchRecipes()">{{ option.label }}</div>
                    </li>
                </ul>
                <button @click="toggleSortDirection" class="btn btn-light">
                    <i v-if="sortDirection === 'ASC'" class="fas fa-chevron-up"></i>
                    <i v-else class="fas fa-chevron-down"></i>
                </button>
            </div>

            <div class="results">
                <div class="filter">
                    <button type="button" class="collapsible filter-header">Dish Type <span>+</span></button>
                    <ul class="content col2">
                        <li v-for="dishtype in dishtypes">
                            <input type="checkbox" :id="dishtype.id" name="dishtypes" :value="dishtype.value" @change="searchRecipes" v-model="dishtype.checked">
                            <label :for="dishtype.id">{{ dishtype.value }}</label><br>
                        </li>
                    </ul>

                    <button type="button" class="collapsible filter-header">Diet <span>+</span></button>
                    <ul class="content col2">
                        <li v-for="diet in diets">
                            <input type="checkbox" :id="diet.id" name="diets" :value="diet.value" @change="searchRecipes" v-model="diet.checked">
                            <label :for="diet.id">{{ diet.value }}</label><br>
                        </li>
                    </ul>

                    <button type="button" class="collapsible filter-header">Cuisine <span>+</span></button>
                    <ul class="content col2">
                        <li v-for="cuisine in cuisines">
                            <input type="checkbox" :id="cuisine.id" name="cuisines" :value="cuisine.value" @change="searchRecipes" v-model="cuisine.checked">
                            <label :for="cuisine.id">{{ cuisine.value }}</label><br>
                        </li>
                    </ul>

                    <!-- SELECT servings FROM nomsters.recipe GROUP BY servings;
                    <button type="button" class="collapsible filter-header">Serving <span>+</span></button>
                    <ul class="content col5">
                        <li v-for="serving in servings">
                            <input type="checkbox" :id="serving.id" name="servings" :value="serving.value" @change="searchRecipes">
                            <label :for="serving.id">{{ serving.value }}</label><br>
                        </li>
                    </ul> -->

                    <button type="button" class="collapsible filter-header">Ready In Minutes <span>+</span></button>
                    <div class="content col2">
                        <input type="radio" id="30" name="readyInMinutes" value="30" v-model="selectedMaxReadyInMinutes" @change="setMinNumber">
                        <label for="30">&lt;= 30mins</label><br>
                        <input type="radio" id="60" name="readyInMinutes" value="60" v-model="selectedMaxReadyInMinutes" @change="setMinNumber">
                        <label for="60">&lt;= 1hr</label><br>
                        <input type="radio" id="120" name="readyInMinutes" value="120" v-model="selectedMaxReadyInMinutes" @change="setMinNumber">
                        <label for="120">&lt;= 2hr</label><br>
                        <input type="radio" id="121" name="readyInMinutes" value="120" v-model="selectedMinReadyInMinutes" @change="setMaxNumber">
                        <label for="121">&gt; 2hr</label><br>
                    </div>

                    <div class="filter-header">Calories</div>
                    <div class="min-max-slider" data-legendnum="2" id="calories" :data-rangemin="minCalorie" :data-rangemax="maxCalorie">
                        <!-- <label for="min">Minimum Calorie</label> -->
                        <span class="lower value">{{Math.round(selectedMinCalories)}} kcal</span>
                        <span class="upper value">- {{Math.round(selectedMaxCalories)}} kcal</span>
                        <input id="min" class="min" name="minCalorie" type="range" step="1" v-model="selectedMinCalories" :min="minCalorie" :max="maxCalorie" @change="searchRecipes"/>
                        <!-- <label for="max">Maximum Calorie</label> -->
                        <input id="max" class="max" name="maxCalorie" type="range" step="1" v-model="selectedMaxCalories" :min="minCalorie" :max="maxCalorie" @change="searchRecipes"/>
                        <div class="legend" style="margin-top: 14px;"><div>{{Math.round(minCalorie)}} kcal</div><div>{{Math.round(maxCalorie)}} kcal</div></div>
                    </div>

                    <div class="filter-header">Servings</div>
                    <div class="min-max-slider" data-legendnum="2" id="servings" :data-rangemin="minServing" :data-rangemax="maxServing">
                        <!-- <label for="min">Minimum Calorie</label> -->
                        <span class="lower value">{{Math.round(selectedMinServings)}}</span>
                        <span class="upper value">- {{Math.round(selectedMaxServings)}}</span>
                        <input id="min" class="min" name="minCalorie" type="range" step="1"  v-model="selectedMinServings" :min="minServing" :max="maxServing" @change="searchRecipes"/>
                        <!-- <label for="max">Maximum Calorie</label> -->
                        <input id="max" class="max" name="maxCalorie" type="range" step="1"  v-model="selectedMaxServings" :min="minServing" :max="maxServing" @change="searchRecipes"/>
                        <div class="legend" style="margin-top: 14px;"><div>{{Math.round(minServing)}}</div><div>{{Math.round(maxServing)}}</div></div>
                    </div>

                    <div class="filter-header">Price Per Serving</div>
                    <div class="min-max-slider" data-legendnum="2" id="pricePerServing" :data-rangemin="minPrice" :data-rangemax="maxPrice">
                        <!-- <label for="min">Minimum Price</label> -->
                        <span class="lower price value">{{Math.round(selectedMinPrice)}}</span>
                        <span class="upper price value">{{Math.round(selectedMaxPrice)}}</span>
                        <input id="min" class="min" name="minPrice" type="range" step="1" v-model="selectedMinPrice" :min="minPrice" :max="maxPrice" @change="searchRecipes"/>
                        <!-- <label for="max">Maximum Price</label> -->
                        <input id="max" class="max" name="maxPrice" type="range" step="1" v-model="selectedMaxPrice" :min="minPrice" :max="maxPrice" @change="searchRecipes"/>
                        <div class="legend" style="margin-top: 14px;"><div>${{Math.round(minPrice)}}</div><div>${{Math.round(maxPrice)}}</div></div>
                    </div>
                </div>
                <div class="container-listing-wrap">
                    <recipe-listing :recipe="recipes" v-if="!isError"></recipe-listing>
                    <div v-else class="alert alert-danger w-100 d-flex align-items-center justify-content-center" role="alert">
                        <p>{{errorMessage}}</p>
                    </div>
                </div>
            </div>
        </div>
        <app-footer></app-footer>
    </div>

    <!-- Bootstrap Bundle with Popper -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.1/dist/js/bootstrap.bundle.min.js"
    integrity="sha384-HwwvtgBNo3bZJJLYd8oVXjrBZt8cqVSpeBNS5n7C8IVInixGAoxmnlMuBnhbgrkm"
    crossorigin="anonymous"></script>
    <script src="component/navbar.js"></script>
    <script src="component/randomRecipeGenerator.js"></script>
    <script src="component/listing.js"></script>
    <script src="component/footer.js"></script>

    <script>  
        const headers = {
            Authorization: `Bearer ${token}`,
        };

        function initSliders(){
            var sliders = document.querySelectorAll('.min-max-slider');
            sliders.forEach( function(slider) {
                init(slider);
            });
        }

        const app = Vue.createApp({
            components: {
                'app-footer': footer,
            },
            data() {
                return {
                    selectedOption: 'Sort by',
                    options: [
                        { label: 'Popularity', value: 'aggregateLikes' },
                        { label: 'Healthiness', value: 'healthScore' },
                    ],
                    dishtypes: [],
                    diets: [],
                    cuisines: [],
                    minCalorie: 0,
                    maxCalorie: 10,
                    selectedMinCalories: 0,
                    selectedMaxCalories: 0,
                    minPrice: 0,
                    maxPrice: 10,
                    selectedMinPrice: 0,
                    selectedMaxPrice: 0,
                    minServing: 0,
                    maxServing: 10,
                    selectedMinServings: 0,
                    selectedMaxServings: 0,
                    selectedSort: "",
                    sortDirection: "ASC",
                    recipes: [],
                    selectedMinReadyInMinutes: Number.MIN_SAFE_INTEGER,
                    selectedMaxReadyInMinutes: Number.MAX_SAFE_INTEGER,
                    isError: false,
                    errorMessage: "",
                    title: "",
                    allrecipes: [],
                    titlequery: "All Recipes",
                };
            },
            mounted() {
                this.fetchAllRecipes();
                this.fetchMinMax();
                
                this.fetchCuisines();
                this.fetchDishTypes();
            },
            computed: {
                selectedDishtypes() {
                    const selectedItems = this.dishtypes.filter(item => item.checked).map(item => item.value);
                    return selectedItems.join(', '); 
                },
                selectedDiets() {
                    const selectedItems = this.diets.filter(item => item.checked).map(item => item.value);
                    return selectedItems.join(', '); 
                },
                selectedCuisines() {
                    const selectedItems = this.cuisines.filter(item => item.checked).map(item => item.value);
                    return selectedItems.join(', '); 
                },
            },
            methods: {
                selectOption(option) {
                    this.selectedOption = option.label;
                    this.selectedSort = option.value;
                },
                fetchAllRecipes(){
                    axios.get('https://leaptron2.dscloud.me:3000/api/recipe', {
                        headers:headers
                    }).then(response => {
                        console.log(response.data)
                        this.allrecipes = response.data
                        console.log(this.allrecipes)
                    }).catch( error => {
                        console.log(error.response.data.message);
                        this.errorMessage = error.response.data.message;
                        if (this.errorMessage === "Invalid token") window.location.href = './index.html';
                        this.allrecipes = [];
                        this.isError = true;
                    });
                },
                fetchDiets(){
                    axios.get('https://leaptron2.dscloud.me:3000/api/diet', {
                        headers:headers
                    }).then(response => {
                        this.diets = response.data.map(item => ({
                            id: item.name.replace(/\s+/g, '_').toLowerCase(),
                            value: item.name,
                            checked: false
                        }))
                        this.fetchUserDiet();
                    }).catch( error => {
                        console.log(error.response.data.message);
                        this.errorMessage = error.response.data.message;
                        if (this.errorMessage === "Invalid token") window.location.href = './index.html';
                        this.isError = true;
                    });
                },
                fetchCuisines(){
                    axios.get('https://leaptron2.dscloud.me:3000/api/cuisine', {
                        headers:headers
                    }).then(response => {
                        this.cuisines = response.data.map(item => ({
                            id: item.name.replace(/\s+/g, '_').toLowerCase(),
                            value: item.name,
                            checked: false
                        }))
                    }).catch( error => {
                        console.log(error.response.data.message);
                        this.errorMessage = error.response.data.message;
                        if (this.errorMessage === "Invalid token") window.location.href = './index.html';
                        this.isError = true;
                    });
                },
                fetchDishTypes(){
                    axios.get('https://leaptron2.dscloud.me:3000/api/dishType', {
                        headers:headers
                    }).then(response => {
                        this.dishtypes = response.data.map(item => ({
                            id: item.name.replace(/\s+/g, '_').toLowerCase(),
                            value: item.name,
                            checked: false
                        }))
                    }).catch( error => {
                        console.log(error.response.data.message);
                        this.errorMessage = error.response.data.message;
                        if (this.errorMessage === "Invalid token") window.location.href = './index.html';
                        this.isError = true;
                    });
                },
                fetchMinMax(){
                    axios.get('https://leaptron2.dscloud.me:3000/api/recipe/minMax', {
                        headers:headers
                    }).then(response => {
                        let data = response.data;
                        
                        this.minCalorie = data.minCalories;
                        this.selectedMinCalories = data.minCalories;
                        this.maxCalorie = data.maxCalories;
                        this.selectedMaxCalories = data.maxCalories;
                        this.minServing = data.minServings;
                        this.selectedMinServings = data.minServings;
                        this.maxServing = data.maxServings;
                        this.selectedMaxServings = data.maxServings;
                        this.minPrice = data.minPrice;
                        this.selectedMinPrice = data.minPrice;
                        this.maxPrice = data.maxPrice;
                        this.selectedMaxPrice = data.maxPrice;

                        initSliders();

                        this.fetchDiets();
                    }).catch( error => {
                        console.log(error.response.data.message);
                        this.errorMessage = error.response.data.message;
                        if (this.errorMessage === "Invalid token") window.location.href = './index.html';
                        this.isError = true;
                    });
                },
                fetchUserDiet(){
                    axios.get(`https://leaptron2.dscloud.me:3000/api/user/${userId}`, {
                        headers:headers,
                    }).then(response => {
                        console.log(response.data.diets)
                        response.data.diets.forEach(diet => {
                            const option = this.diets.find(option => option.value === diet);
                                if (option) {
                                    option.checked = true;
                                }
                            });
                        console.log(this.diets)
                        
                        // this.searchRecipes();

                        const urlParams = new URLSearchParams(window.location.search);
                        this.searchRecipes(urlParams.get('search'));
                        if (urlParams.has('search')) {
                            urlParams.delete('search');
                            const newUrl = window.location.protocol + '//' + window.location.host + window.location.pathname + '?' + urlParams.toString();
                            window.history.pushState({}, '', newUrl);
                        }
                    }).catch( error => {
                        console.log(error.response.data.message);
                        // this.errorMessage = error.response.data.message;
                        // this.recipes = [];
                        // this.isError = true;
                    });
                },
                searchRecipes(titleQuery){
                    console.log("searching");
                    console.log(titleQuery);
                    if (titleQuery === "DESC" || titleQuery === "ASC"){
                        titleQuery = "";
                    }
                    this.title = (typeof titleQuery === 'string') ? titleQuery : this.title;
                    axios.get('https://leaptron2.dscloud.me:3000/api/recipe', {
                        headers:headers,
                        params: {
                            title: this.title, 
                            cuisine: this.selectedCuisines,
                            dishtype: this.selectedDishtypes,
                            diet: this.selectedDiets,
                            minServings: this.selectedMinServings,
                            maxServings: this.selectedMaxServings, 
                            minCalories: this.selectedMinCalories,
                            maxCalories: this.selectedMaxCalories,
                            minPrice: this.selectedMinPrice, 
                            maxPrice: this.selectedMaxPrice, 
                            minReadyInMinutes: this.selectedMinReadyInMinutes, // not done
                            maxReadyInMinutes: this.selectedMaxReadyInMinutes, // not done
                            sort: this.selectedSort, 
                            order: this.sortDirection
                        }
                    }).then(response => {
                        console.log(response.data)
                        console.log(titleQuery)
                        console.log(this.title)

                        this.isError = false;
                        this.recipes = response.data;

                        if (titleQuery != undefined && titleQuery.length > 0) {
                            this.titlequery = "Showing recipes for '" + titleQuery + "'";
                        } else {
                            this.titlequery = "All Recipes";
                        }
                    }).catch( error => {
                        console.log(error.response.data.message);
                        console.log(titleQuery);
                        this.errorMessage = error.response.data.message;
                        if (this.errorMessage === "Invalid Token") window.location.href = './index.html';
                        this.recipes = [];
                        this.isError = true;
                        this.titlequery = "No recipe found for '" + titleQuery + "'";
                    });
                },
                toggleSortDirection() {
                    this.sortDirection = this.sortDirection === 'ASC' ? 'DESC' : 'ASC';
                },
                setMaxNumber(){
                    this.selectedMinReadyInMinutes = Number.MIN_SAFE_INTEGER
                    console.log("hwerwer")
                    this.searchRecipes()
                },
                setMinNumber(){
                    this.selectedMaxReadyInMinutes = Number.MAX_SAFE_INTEGER
                    console.log("kjrngesigiuui")
                    this.searchRecipes()
                },
                changeColor() {
                    this.fav = this.fav === 0 ? 1 : 0;
                },
            }, 
            watch: {
                sortDirection: 'searchRecipes', 
            }
        });

        app.component('app-nav', {
            data() {
                return {
                    showIsActive: false,
                    random: []
                }
            },
            props: {
                allrecipes: {
                    type: Array,
                    required: true
                },
                size: {
                    type: Number,
                    required: false,
                    default: 12
                }
            },
            methods: {
                showHideModal() {
                    this.showIsActive = !this.showIsActive;

                    this.generateRandomRecipe();
                },
                generateRandomRecipe() {
                    if (this.allrecipes.length > 0) {
                        const length = this.allrecipes.length;
                        const r = this.allrecipes[Math.floor(Math.random() * length)];
            
                        console.log(this.random);
                        this.random = r;
                    }
                },
                closeModal() {
                    this.showIsActive = !this.showIsActive;
                },
            },
            template: navbar.template + `
                <div class="random-recipe" :class="{active: showIsActive}">
                    <div class="overlay" @click="closeModal"></div>
                    <div class="modal-box">
                        <h3>Random Recipe Generator</h3>
                        ${listing.single}
                        <div class="buttons">
                            <!-- <button class="btn close-btn" @click="showHideModal">Close</button> -->
                            <button class="btn decide-btn" @click="generateRandomRecipe">Regenerate</button>
                            <button class="btn decide-btn"><a href="recipeDetail.html?">Go to Recipe</a></button>
                        </div>
                    </div>
                </div>
            `,
        });
        
        app.component('recipe-listing', {
            data() {
                return {
                    pageNumber: 1,
                    fav: 0,
                }
            },
            props: {
                recipe: {
                    type: Array,
                    required: true
                },
                size: {
                    type: Number,
                    required: false,
                    default: 12
                }
            },
            methods:{
                nextPage() {
                    this.pageNumber++;
                },
                prevPage() {
                    this.pageNumber--;
                },
                changeColor() {
                    this.fav = this.fav === 0 ? 1 : 0;
                }
    
            },
            computed: {
                pageCount() {
                    let l = this.recipe.length;
                    let s = this.size;
                    return Math.ceil(l/s);
                },
                recipeData() {
                    const start = this.pageNumber * this.size - this.size;
                    const end = start + this.size;
                    return this.recipe.slice(start, end);
                }
            },
            template: listing.template + `
                <div class="m-4 d-flex align-items-center justify-content-end w-100">
                    <p class="m-1">Total {{ pageCount }} pages</p>
                    <button type="button" class="btn btn-sm m-1" v-if="pageNumber > 1" @click="prevPage"> &lt; </button>
                    <button type="button" class="btn btn-sm m-1 text-secondary border-0" v-else disabled> &lt; </button>
                    <template v-if="pageCount <= 7">
                        <button type="button" class="btn btn-sm m-1 rounded-circle" :class="{ 'btn-dark': pageNumber === page }" v-for="page in pageCount" @click="pageNumber = page"> {{ page }}
                        </button>
                    </template>
                    <template v-else>
                        <button type="button" class="btn btn-sm m-1 rounded-circle" :class="{ 'btn-dark': pageNumber === 1 }" @click="pageNumber = 1">1</button>
                        <template v-if="pageNumber <= 6">
                            <button type="button" class="btn btn-sm m-1 rounded-circle" :class="{ 'btn-dark': pageNumber === page + 1 }" v-for="page in 5" @click="pageNumber = page + 1"> {{ page + 1 }}</button>
                            <span class="m-1">...</span>
                            <button type="button" class="btn btn-sm m-1 rounded-circle" :class="{ 'btn-dark': pageNumber === pageCount }" @click="pageNumber = pageCount">{{ pageCount }}</button>
                        </template>
                        <template v-else-if="pageNumber >= pageCount - 4">
                            <span class="m-1">...</span>
                            <button type="button" class="btn btn-sm m-1 rounded-circle" :class="{ 'btn-dark': pageNumber === page + pageCount - 6 }" v-for="page in 6" @click="pageNumber = page + pageCount - 6"> {{ page + pageCount - 6 }}</button>
                        </template>
                        <template v-else>
                            <span class="m-1">...</span>
                            <button type="button" class="btn btn-sm m-1 rounded-circle" :class="{ 'btn-dark': pageNumber === page }" @click="pageNumber = pageNumber - 2">{{ pageNumber - 2 }}</button>
                            <button type="button" class="btn btn-sm m-1 rounded-circle" :class="{ 'btn-dark': pageNumber === page }" @click="pageNumber = pageNumber - 1">{{ pageNumber - 1 }}</button>
                            <button type="button" class="btn btn-sm m-1 rounded-circle btn-dark" disabled>{{ pageNumber }}</button>
                            <button type="button" class="btn btn-sm m-1 rounded-circle" :class="{ 'btn-dark': pageNumber === page }" @click="pageNumber = pageNumber + 1">{{ pageNumber + 1 }}</button>
                            <button type="button" class="btn btn-sm m-1 rounded-circle" :class="{ 'btn-dark': pageNumber === page }" @click="pageNumber = pageNumber + 2">{{ pageNumber + 2 }}</button>
                            <span class="m-1">...</span>
                            <button type="button" class="btn btn-sm m-1 rounded-circle" :class="{ 'btn-dark': pageNumber === pageCount }" @click="pageNumber = pageCount">{{ pageCount }}</button>
                        </template>
                    </template>
                    <button type="button" class="btn btn-sm m-1" v-if="pageNumber < pageCount" @click="nextPage"> &gt; </button>
                    <button type="button" class="btn btn-sm m-1 text-secondary border-0" v-else disabled> &gt; </button>
                </div>
            `
        });

        app.mount('#app');


        var collapsible = document.getElementsByClassName("collapsible");
        var i;

        for (i = 0; i < collapsible.length; i++) {
            collapsible[i].addEventListener("click", function() {
                this.classList.toggle("active");
                var content = this.nextElementSibling;
                if (content.style.opacity === "1") {
                    content.style.opacity = "0";
                    content.style.height = "0";
                    this.getElementsByTagName("span")[0].innerText = "+";
                } else {
                    content.style.opacity = "1";
                    content.style.height = "auto";
                    this.getElementsByTagName("span")[0].innerText = "-";
                }
            });
        }

        var thumbsize = 14;

        function draw(slider,splitvalue) {

            /* set function vars */
            var id = slider.getAttribute('id');
            var min = slider.querySelector('.min');
            var max = slider.querySelector('.max');
            var lower = slider.querySelector('.lower');
            var upper = slider.querySelector('.upper');
            var legend = slider.querySelector('.legend');
            var thumbsize = parseInt(slider.getAttribute('data-thumbsize'));
            var rangewidth = parseInt(slider.getAttribute('data-rangewidth'));
            var rangemin = parseInt(slider.getAttribute('data-rangemin'));
            var rangemax = parseInt(slider.getAttribute('data-rangemax'));

            /* set min and max attributes */
            min.setAttribute('max',splitvalue);
            max.setAttribute('min',splitvalue);

            var widthMin = parseInt(thumbsize + ((splitvalue - rangemin)/(rangemax - rangemin))*(rangewidth - (2*thumbsize)));
            var widthMax = parseInt(thumbsize + ((rangemax - splitvalue)/(rangemax - rangemin))*(rangewidth - (2*thumbsize)));
            /* console.log(rangemax)
            console.log(rangemin)
            console.log(rangemax - rangemin) */
            /* set css */
            min.style.width = widthMin + 'px';
            max.style.width = widthMax + 'px';
            /*min.style.width = 50+'%';
            max.style.width = 100+'%';*/
            min.style.left = '0px';
            max.style.left = parseInt(min.style.width)+'px';
            /*max.style.left = 0+'%';*/
            min.style.top = lower.offsetHeight+'px';
            max.style.top = lower.offsetHeight+'px';
            legend.style.marginTop = min.offsetHeight+'px';
            slider.style.height = (lower.offsetHeight + min.offsetHeight + legend.offsetHeight)+'px';
            
            /* correct for 1 off at the end */
            if(max.value>(rangemax - 1)) max.setAttribute('data-value',rangemax);

            /* write value and labels */
            max.value = max.getAttribute('data-value'); 
            min.value = min.getAttribute('data-value');

            /*if (id == "calories") {
                lower.innerHTML = min.getAttribute('data-value') + " kcal";
                upper.innerHTML = "- " + max.getAttribute('data-value') + " kcal";
            } else if (id == "servings") {
                lower.innerHTML = min.getAttribute('data-value');
                upper.innerHTML = " " + max.getAttribute('data-value');
            } else {
                lower.innerHTML = min.getAttribute('data-value');
                upper.innerHTML = max.getAttribute('data-value');
            }*/

        }

        function init(slider) {
            /* set function vars */
            var id = slider.getAttribute('id');
            var min = slider.querySelector('.min');
            var max = slider.querySelector('.max');
            var rangemin = Number(min.getAttribute('min'));
            var rangemax = Number(max.getAttribute('max'));
            var avgvalue = (rangemin + rangemax)/2;
            var legendnum = slider.getAttribute('data-legendnum');

            /* set data-values */
            min.setAttribute('data-value',rangemin);
            max.setAttribute('data-value',rangemax);
            
            /* set data vars */
            slider.setAttribute('data-rangemin',rangemin); 
            slider.setAttribute('data-rangemax',rangemax); 
            slider.setAttribute('data-thumbsize',thumbsize); 
            slider.setAttribute('data-rangewidth',slider.offsetWidth);

            // /* write labels */
            // var lower = document.createElement('span');
            // var upper = document.createElement('span');

            // if (id == "pricePerServing") {
            //     lower.classList.add('lower','value','price');
            //     upper.classList.add('upper','value','price');
            // } else {
            //     lower.classList.add('lower','value');
            //     upper.classList.add('upper','value');
            // }
            
            // lower.appendChild(document.createTextNode(rangemin));
            // upper.appendChild(document.createTextNode(rangemax));
            
            // slider.insertBefore(lower,min.previousElementSibling);
            // slider.insertBefore(upper,min.previousElementSibling);
            
            // /* write legend */
            // var legend = document.createElement('div');
            // legend.classList.add('legend');
            // var legendvalues = [];
            // for (var i = 0; i < legendnum; i++) {
            //     legendvalues[i] = document.createElement('div');
            //     var val = Math.round(rangemin+(i/(legendnum-1))*(rangemax - rangemin));
            //     legendvalues[i].appendChild(document.createTextNode(val));
            //     legend.appendChild(legendvalues[i]);

            // } 
            // slider.appendChild(legend);

            /* draw */
            draw(slider,avgvalue);

            /* events */
            min.addEventListener("input", function() {update(min);});
            max.addEventListener("input", function() {update(max);});
        }

        function update(el){
            /* set function vars */
            var slider = el.parentElement;
            var min = slider.querySelector('#min');
            var max = slider.querySelector('#max');
            var minvalue = Math.floor(min.value);
            var maxvalue = Math.floor(max.value);
            
            /* set inactive values before draw */
            min.setAttribute('data-value',minvalue);
            max.setAttribute('data-value',maxvalue);

            var avgvalue = (minvalue + maxvalue)/2;

            /* draw */
            draw(slider,avgvalue);
        }
    </script>
</body>

</html>